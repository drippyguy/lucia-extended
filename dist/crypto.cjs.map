{"version":3,"sources":["../src/crypto.ts"],"sourcesContent":["import { encodeHex, decodeHex } from \"oslo/encoding\";\nimport { constantTimeEqual, generateRandomString, alphabet } from \"oslo/crypto\";\nimport { scrypt } from \"./scrypt/index.js\";\n\nimport type { PasswordHashingAlgorithm } from \"oslo/password\";\n\nexport type { PasswordHashingAlgorithm } from \"oslo/password\";\n\nasync function generateScryptKey(data: string, salt: string, blockSize = 16): Promise<ArrayBuffer> {\n\tconst encodedData = new TextEncoder().encode(data);\n\tconst encodedSalt = new TextEncoder().encode(salt);\n\tconst keyUint8Array = await scrypt(encodedData, encodedSalt, {\n\t\tN: 16384,\n\t\tr: blockSize,\n\t\tp: 1,\n\t\tdkLen: 64\n\t});\n\treturn keyUint8Array;\n}\n\nexport function generateId(length: number): string {\n\treturn generateRandomString(length, alphabet(\"0-9\", \"a-z\"));\n}\n\nexport class Scrypt implements PasswordHashingAlgorithm {\n\tasync hash(password: string): Promise<string> {\n\t\tconst salt = encodeHex(crypto.getRandomValues(new Uint8Array(16)));\n\t\tconst key = await generateScryptKey(password.normalize(\"NFKC\"), salt);\n\t\treturn `${salt}:${encodeHex(key)}`;\n\t}\n\tasync verify(hash: string, password: string): Promise<boolean> {\n\t\tconst parts = hash.split(\":\");\n\t\tif (parts.length !== 2) return false;\n\n\t\tconst [salt, key] = parts;\n\t\tconst targetKey = await generateScryptKey(password.normalize(\"NFKC\"), salt);\n\t\treturn constantTimeEqual(targetKey, decodeHex(key));\n\t}\n}\n\nexport class LegacyScrypt implements PasswordHashingAlgorithm {\n\tasync hash(password: string): Promise<string> {\n\t\tconst salt = encodeHex(crypto.getRandomValues(new Uint8Array(16)));\n\t\tconst key = await generateScryptKey(password.normalize(\"NFKC\"), salt);\n\t\treturn `s2:${salt}:${encodeHex(key)}`;\n\t}\n\tasync verify(hash: string, password: string): Promise<boolean> {\n\t\tconst parts = hash.split(\":\");\n\t\tif (parts.length === 2) {\n\t\t\tconst [salt, key] = parts;\n\t\t\tconst targetKey = await generateScryptKey(password.normalize(\"NFKC\"), salt, 8);\n\t\t\tconst result = constantTimeEqual(targetKey, decodeHex(key));\n\t\t\treturn result;\n\t\t}\n\t\tif (parts.length !== 3) return false;\n\t\tconst [version, salt, key] = parts;\n\t\tif (version === \"s2\") {\n\t\t\tconst targetKey = await generateScryptKey(password.normalize(\"NFKC\"), salt);\n\t\t\treturn constantTimeEqual(targetKey, decodeHex(key));\n\t\t}\n\t\treturn false;\n\t}\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,sBAAqC;AACrC,oBAAkE;AAClE,oBAAuB;AAMvB,eAAe,kBAAkB,MAAc,MAAc,YAAY,IAA0B;AAClG,QAAM,cAAc,IAAI,YAAY,EAAE,OAAO,IAAI;AACjD,QAAM,cAAc,IAAI,YAAY,EAAE,OAAO,IAAI;AACjD,QAAM,gBAAgB,UAAM,sBAAO,aAAa,aAAa;AAAA,IAC5D,GAAG;AAAA,IACH,GAAG;AAAA,IACH,GAAG;AAAA,IACH,OAAO;AAAA,EACR,CAAC;AACD,SAAO;AACR;AAEO,SAAS,WAAW,QAAwB;AAClD,aAAO,oCAAqB,YAAQ,wBAAS,OAAO,KAAK,CAAC;AAC3D;AAEO,MAAM,OAA2C;AAAA,EACvD,MAAM,KAAK,UAAmC;AAC7C,UAAM,WAAO,2BAAU,OAAO,gBAAgB,IAAI,WAAW,EAAE,CAAC,CAAC;AACjE,UAAM,MAAM,MAAM,kBAAkB,SAAS,UAAU,MAAM,GAAG,IAAI;AACpE,WAAO,GAAG,IAAI,QAAI,2BAAU,GAAG,CAAC;AAAA,EACjC;AAAA,EACA,MAAM,OAAO,MAAc,UAAoC;AAC9D,UAAM,QAAQ,KAAK,MAAM,GAAG;AAC5B,QAAI,MAAM,WAAW;AAAG,aAAO;AAE/B,UAAM,CAAC,MAAM,GAAG,IAAI;AACpB,UAAM,YAAY,MAAM,kBAAkB,SAAS,UAAU,MAAM,GAAG,IAAI;AAC1E,eAAO,iCAAkB,eAAW,2BAAU,GAAG,CAAC;AAAA,EACnD;AACD;AAEO,MAAM,aAAiD;AAAA,EAC7D,MAAM,KAAK,UAAmC;AAC7C,UAAM,WAAO,2BAAU,OAAO,gBAAgB,IAAI,WAAW,EAAE,CAAC,CAAC;AACjE,UAAM,MAAM,MAAM,kBAAkB,SAAS,UAAU,MAAM,GAAG,IAAI;AACpE,WAAO,MAAM,IAAI,QAAI,2BAAU,GAAG,CAAC;AAAA,EACpC;AAAA,EACA,MAAM,OAAO,MAAc,UAAoC;AAC9D,UAAM,QAAQ,KAAK,MAAM,GAAG;AAC5B,QAAI,MAAM,WAAW,GAAG;AACvB,YAAM,CAACA,OAAMC,IAAG,IAAI;AACpB,YAAM,YAAY,MAAM,kBAAkB,SAAS,UAAU,MAAM,GAAGD,OAAM,CAAC;AAC7E,YAAM,aAAS,iCAAkB,eAAW,2BAAUC,IAAG,CAAC;AAC1D,aAAO;AAAA,IACR;AACA,QAAI,MAAM,WAAW;AAAG,aAAO;AAC/B,UAAM,CAAC,SAAS,MAAM,GAAG,IAAI;AAC7B,QAAI,YAAY,MAAM;AACrB,YAAM,YAAY,MAAM,kBAAkB,SAAS,UAAU,MAAM,GAAG,IAAI;AAC1E,iBAAO,iCAAkB,eAAW,2BAAU,GAAG,CAAC;AAAA,IACnD;AACA,WAAO;AAAA,EACR;AACD;","names":["salt","key"]}